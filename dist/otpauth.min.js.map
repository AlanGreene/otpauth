{"version":3,"sources":["webpack://OTPAuth/ [synthetic:base] ","webpack://OTPAuth/ [synthetic:util/global] ","webpack://OTPAuth/ [synthetic:util/defines] ","webpack://OTPAuth/ [synthetic:util/defineproperty] ","webpack://OTPAuth/ [synthetic:es6/symbol] ","webpack://OTPAuth/webpack/universalModuleDefinition","webpack://OTPAuth//tmp/tmp-123441A43GfwbUU3C.tmp","webpack://OTPAuth/webpack/bootstrap","webpack://OTPAuth/otpauth.min.js","webpack://OTPAuth/./src/utils.js","webpack://OTPAuth/./src/crypto.js","webpack://OTPAuth/(webpack)/buildin/global.js","webpack://OTPAuth/./src/otp.js","webpack://OTPAuth/./src/uri.js","webpack://OTPAuth/./src/secret.js","webpack://OTPAuth/./src/main.js"],"names":["h","scope","getGlobal","g","window","global","this","ASSUME_ES5","ASSUME_NO_NATIVE_MAP","ASSUME_NO_NATIVE_SET","defineProperty","Object","defineProperties","f","d","Array","prototype","value","SYMBOL_PREFIX","initSymbol","Symbol","initSymbolIterator","iterator","configurable","writable","arrayIterator","iteratorPrototype","length","done","next","P","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","__webpack_require__.d","name","getter","o","enumerable","get","r","__webpack_require__.r","toStringTag","t","__webpack_require__.t","mode","__esModule","ns","create","key","bind","n","__webpack_require__.n","getDefault","getModuleExports","__webpack_require__.o","object","property","hasOwnProperty","p","s","__webpack_exports__","Utils","InternalUtils","uint","decode","Utils.uint.decode","buf","arr","Uint8Array","num","encode","Utils.uint.encode","ArrayBuffer","acc","raw","Utils.raw.decode","str","String","fromCharCode","Utils.raw.encode","charCodeAt","b32","alphabet","Utils.b32.decode","bits","Utils.b32.encode","strUpp","toUpperCase","index","idx","indexOf","TypeError","hex","Utils.hex.decode","hexByte","toString","Utils.hex.encode","parseInt","substr","isNode","process","require","InternalUtils.require","eval","sjcl","cipher","hash","keyexchange","misc","codec","exception","corrupt","message","this.toString","invalid","bug","notReady","bitArray","bitSlice","a","bstart","bend","_shiftRight","slice","undefined","clamp","extract","blength","sh","Math","floor","concat","a1","a2","last","shift","getPartial","bitLength","len","ceil","partial","x","_end","round","equal","b","carry","out","push","shift2","pop","_xor4","y","byteswapM","v","globals","globals.ArrayBuffer","DataView","globals.DataView","arrayBuffer","fromBits","padding","padding_count","ol","tmp","setUint32","byteLength","buffer","smallest","setUint8","getUint8","toBits","inView","getUint32","hexDumpBuffer","stringBufferView","string","e","getUint16","width","join","console","log","sha1","sjcl.hash.sha1","_h","_buffer","_length","reset","sjcl.hash.sha1.hash","data","update","finalize","blockSize","_init","utf8String","nl","Uint32Array","j","_block","subarray","splice","_key","_f","_S","words","w","sha256","sjcl.hash.sha256","_precompute","sjcl.hash.sha256.hash","frac","prime","factor","isPrime","pow","k","h0","h1","h2","h3","h4","h5","h6","h7","sha512","sjcl.hash.sha512","sjcl.hash.sha512.hash","_initr","_keyr","frac2","h0h","h0l","h1h","h1l","h2h","h2l","h3h","h3l","h4h","h4l","h5h","h5l","h6h","h6l","h7h","h7l","ah","al","bh","bl","ch","cl","dh","dl","eh","el","fh","fl","gh","gl","hh","hl","wrh","wrl","gamma0xh","gamma0xl","gamma0h","gamma0l","gamma1xh","gamma1xl","gamma1h","gamma1l","wr7h","wr16h","wr16l","chh","chl","majh","majl","sigma0h","sigma0l","krh","krl","t1l","t1h","t2l","t2h","hmac","sjcl.misc.hmac","Hash","_hash","exKey","bs","_baseHash","_resultHash","encrypt","mac","sjcl.misc.hmac.prototype.mac","_updated","digest","sjcl.misc.hmac.prototype.reset","sjcl.misc.hmac.prototype.update","sjcl.misc.hmac.prototype.digest","result","Crypto","sjcl__WEBPACK_IMPORTED_MODULE_0__","NodeCrypto","bufferFrom","Buffer","from","arrbuf","nodeBuf","bufferTo","randomBytes","Crypto.randomBytes","size","hmacDigest","Crypto.hmacDigest","algorithm","createHmac","crypto","getRandomValues","msCrypto","warn","random","toLowerCase","Function","constructor","otp_TOTP","issuer","label","secret","secret_Secret","digits","period","otp_HOTP","counter","uri_URI","src_crypto","utils","fromRaw","fromB32","fromHex","OTPURI_REGEX","SECRET_REGEX","ALGORITHM_REGEX","INTEGER_REGEX","POSITIVE_INTEGER_REGEX","parse","uri","uriGroups","decodeURIComponent","match","err","isArray","URIError","uriType","uriLabel","split","uriParams","reduce","cur","pairArr","pairKey","config","OTP","test","stringify","otp","legacyIssuer","isTOTP","encodeURI","generate","pad","offset","validate","token","searchToken","generatedToken","timestamp","Date","now","version","factory","define","amd","OTPAuth","root"],"mappings":"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","file":"otpauth.min.js","sourcesContent":[null,null,null,null,null,"(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OTPAuth\"] = factory();\n\telse\n\t\troot[\"OTPAuth\"] = factory();\n})(this, function() {\nreturn ","/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\"use strict\";\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n  /**\n   * Symmetric ciphers.\n   * @namespace\n   */\n  cipher: {},\n\n  /**\n   * Hash functions.  Right now only SHA256 is implemented.\n   * @namespace\n   */\n  hash: {},\n\n  /**\n   * Key exchange functions.  Right now only SRP is implemented.\n   * @namespace\n   */\n  keyexchange: {},\n  \n  /**\n   * Cipher modes of operation.\n   * @namespace\n   */\n  mode: {},\n\n  /**\n   * Miscellaneous.  HMAC and PBKDF2.\n   * @namespace\n   */\n  misc: {},\n  \n  /**\n   * Bit array encoders and decoders.\n   * @namespace\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /**\n   * Exceptions.\n   * @namespace\n   */\n  exception: {\n    /**\n     * Ciphertext is corrupt.\n     * @constructor\n     */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Invalid parameter.\n     * @constructor\n     */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Bug or missing feature in SJCL.\n     * @constructor\n     */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /**\n     * Something isn't ready.\n     * @constructor\n     */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} blength The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n\n//patch arraybuffers if they don't exist\nif (typeof(ArrayBuffer) === 'undefined') {\n  (function(globals){\n      \"use strict\";\n      globals.ArrayBuffer = function(){};\n      globals.DataView = function(){};\n  }(this));\n}\n\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n  /** Convert from a bitArray to an ArrayBuffer. \n   * Will default to 8byte padding if padding is undefined*/\n  fromBits: function (arr, padding, padding_count) {\n    var out, i, ol, tmp, smallest;\n    padding = padding==undefined  ? true : padding;\n    padding_count = padding_count || 8;\n\n    if (arr.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    ol = sjcl.bitArray.bitLength(arr)/8;\n\n    //check to make sure the bitLength is divisible by 8, if it isn't \n    //we can't do anything since arraybuffers work with bytes, not bits\n    if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {\n      throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n    }\n\n    if (padding && ol%padding_count !== 0){\n      ol += padding_count - (ol%padding_count);\n    }\n\n\n    //padded temp for easy copying\n    tmp = new DataView(new ArrayBuffer(arr.length*4));\n    for (i=0; i<arr.length; i++) {\n      tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits\n    }\n\n    //now copy the final message if we are not going to 0 pad\n    out = new DataView(new ArrayBuffer(ol));\n\n    //save a step when the tmp and out bytelength are ===\n    if (out.byteLength === tmp.byteLength){\n      return tmp.buffer;\n    }\n\n    smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n    for(i=0; i<smallest; i++){\n      out.setUint8(i,tmp.getUint8(i));\n    }\n\n\n    return out.buffer;\n  },\n\n  toBits: function (buffer) {\n    var i, out=[], len, inView, tmp;\n\n    if (buffer.byteLength === 0) {\n      return [];\n    }\n\n    inView = new DataView(buffer);\n    len = inView.byteLength - inView.byteLength%4;\n\n    for (var i = 0; i < len; i+=4) {\n      out.push(inView.getUint32(i));\n    }\n\n    if (inView.byteLength%4 != 0) {\n      tmp = new DataView(new ArrayBuffer(4));\n      for (var i = 0, l = inView.byteLength%4; i < l; i++) {\n        //we want the data to the right, because partial slices off the starting bits\n        tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian, \n      }\n      out.push(\n        sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )\n      ); \n    }\n    return out;\n  },\n\n\n\n  /** Prints a hex output of the buffer contents, akin to hexdump **/\n  hexDumpBuffer: function(buffer){\n      var stringBufferView = new DataView(buffer);\n      var string = '';\n      var pad = function (n, width) {\n          n = n + '';\n          return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n      };\n\n      for (var i = 0; i < stringBufferView.byteLength; i+=2) {\n          if (i%16 == 0) string += ('\\n'+(i).toString(16)+'\\t');\n          string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ');\n      }\n\n      if ( typeof console === undefined ){\n        console = console || {log:function(){}}; //fix for IE\n      }\n      console.log(string.toUpperCase());\n  }\n};\n\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n\t\ti+= this.blockSize) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n             i+= this.blockSize) {\n      \t     this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var t, tmp, a, b, c, d, e,\n    h = this._h;\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n        // When words is passed to _block, it has 16 elements. SHA1 _block\n        // function extends words with new elements (at the end there are 80 elements). \n        // The problem is that if we use Uint32Array instead of Array, \n        // the length of Uint32Array cannot be changed. Thus, we replace words with a \n        // normal Array here.\n        w = Array(80); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<16; j++){\n            w[j] = words[j];\n        }\n    } else {\n        w = words;\n    }\n\n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n\tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor, isPrime;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    for (; i<64; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i] = frac(Math.pow(prime, 1/2));\n        }\n        this._key[i] = frac(Math.pow(prime, 1/3));\n        i++;\n      }\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {Uint32Array|bitArray} w one block of words.\n   * @private\n   */\n  _block:function (w) {  \n    var i, tmp, a, b,\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview Javascript SHA-512 implementation.\n *\n * This implementation was written for CryptoJS by Jeff Mott and adapted for\n * SJCL by Stefan Thomas.\n *\n * CryptoJS (c) 2009–2012 by Jeff Mott. All rights reserved.\n * Released with New BSD License\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Jeff Mott\n * @author Stefan Thomas\n */\n\n/**\n * Context for a SHA-512 operation in progress.\n * @constructor\n */\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha512.hash = function (data) {\n  return (new sjcl.hash.sha512()).update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 1024,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n        var c = new Uint32Array(b);\n        var j = 0;\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(c.subarray(32 * j, 32 * (j+1)));\n            j += 1;\n        }\n        b.splice(0, 32 * j);\n    } else {\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(b.splice(0,32));\n        }\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 32 words, less the 4 length words.\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,32));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-512 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n\n  /**\n   * Least significant 24 bits of SHA512 initialization values.\n   *\n   * Javascript only has 53 bits of precision, so we compute the 40 most\n   * significant bits and add the remaining 24 bits as constants.\n   *\n   * @private\n   */\n  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],\n\n  /*\n  _init:\n  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],\n  */\n\n  /**\n   * The SHA-512 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n\n  /**\n   * Least significant 24 bits of SHA512 key values.\n   * @private\n   */\n  _keyr:\n  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,\n   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,\n   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,\n   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,\n   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,\n   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,\n   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,\n   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,\n   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,\n   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n\n  /*\n  _key:\n  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],\n  */\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    // XXX: This code is for precomputing the SHA256 constants, change for\n    //      SHA512 and re-enable.\n    var i = 0, prime = 2, factor , isPrime;\n\n    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }\n    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }\n\n    for (; i<80; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i*2] = frac(Math.pow(prime, 1/2));\n          this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];\n        }\n        this._key[i*2] = frac(Math.pow(prime, 1/3));\n        this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-512.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, wrh, wrl,\n        h = this._h,\n        k = this._key,\n        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],\n        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],\n        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],\n        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n\t// When words is passed to _block, it has 32 elements. SHA512 _block\n\t// function extends words with new elements (at the end there are 160 elements). \n\t// The problem is that if we use Uint32Array instead of Array, \n\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t// normal Array here.\n        w = Array(160); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<32; j++){\n    \t    w[j] = words[j]; \n        }\n    } else {\n\tw = words;\n    } \n\n    // Working variables\n    var ah = h0h, al = h0l, bh = h1h, bl = h1l,\n        ch = h2h, cl = h2l, dh = h3h, dl = h3l,\n        eh = h4h, el = h4l, fh = h5h, fl = h5l,\n        gh = h6h, gl = h6l, hh = h7h, hl = h7l;\n\n    for (i=0; i<80; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        // Gamma0\n        var gamma0xh = w[(i-15) * 2];\n        var gamma0xl = w[(i-15) * 2 + 1];\n        var gamma0h =\n          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^\n          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^\n           (gamma0xh >>> 7);\n        var gamma0l =\n          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^\n          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^\n          ((gamma0xh << 25) | (gamma0xl >>> 7));\n\n        // Gamma1\n        var gamma1xh = w[(i-2) * 2];\n        var gamma1xl = w[(i-2) * 2 + 1];\n        var gamma1h =\n          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^\n          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^\n           (gamma1xh >>> 6);\n        var gamma1l =\n          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^\n          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^\n          ((gamma1xh << 26) | (gamma1xl >>> 6));\n\n        // Shortcuts\n        var wr7h = w[(i-7) * 2];\n        var wr7l = w[(i-7) * 2 + 1];\n\n        var wr16h = w[(i-16) * 2];\n        var wr16l = w[(i-16) * 2 + 1];\n\n        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);\n      }\n\n      w[i*2]     = wrh |= 0;\n      w[i*2 + 1] = wrl |= 0;\n\n      // Ch\n      var chh = (eh & fh) ^ (~eh & gh);\n      var chl = (el & fl) ^ (~el & gl);\n\n      // Maj\n      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      // Sigma0\n      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\n      // Sigma1\n      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));\n      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));\n\n      // K(round)\n      var krh = k[i*2];\n      var krl = k[i*2+1];\n\n      // t1 = h + sigma1 + ch + K(round) + W(round)\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += krl;\n      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);\n      t1l = t1l + wrl|0;   // FF32..FF34 perf issue https://bugzilla.mozilla.org/show_bug.cgi?id=1054972\n      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash\n    h0l = h[1] = (h0l + al) | 0;\n    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;\n    h1l = h[3] = (h1l + bl) | 0;\n    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;\n    h2l = h[5] = (h2l + cl) | 0;\n    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;\n    h3l = h[7] = (h3l + dl) | 0;\n    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n    h4l = h[9] = (h4l + el) | 0;\n    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;\n    h5l = h[11] = (h5l + fl) | 0;\n    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;\n    h6l = h[13] = (h6l + gl) | 0;\n    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;\n    h7l = h[15] = (h7l + hl) | 0;\n    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;\n  }\n};\n\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};\n; export default sjcl;"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OTPAuth\"] = factory();\n\telse\n\t\troot[\"OTPAuth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Utils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return InternalUtils; });\n/**\n * An object containing some utilities.\n * @type {Object}\n */\nconst Utils = {};\n\n/**\n * UInt conversion.\n * @type {Object}\n */\nUtils.uint = {};\n\n/**\n * Converts an ArrayBuffer to an integer.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {number} Integer.\n */\nUtils.uint.decode = function (buf) {\n\tconst arr = new Uint8Array(buf);\n\tlet num = 0;\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum *= 256;\n\t\tnum += arr[i];\n\t}\n\n\treturn num;\n};\n\n/**\n * Converts an integer to an ArrayBuffer.\n * @param {number} num Integer.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.uint.encode = function (num) {\n\tconst buf = new ArrayBuffer(8);\n\tconst arr = new Uint8Array(buf);\n\tlet acc = num;\n\n\tfor (let i = 7; i >= 0; i--) {\n\t\tif (acc === 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tarr[i] = acc & 255;\n\t\tacc -= arr[i];\n\t\tacc /= 256;\n\t}\n\n\treturn buf;\n};\n\n/**\n * Raw string conversion.\n * @type {Object}\n */\nUtils.raw = {};\n\n/**\n * Converts an ArrayBuffer to a string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} String.\n */\nUtils.raw.decode = function (buf) {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tstr += String.fromCharCode(arr[i]);\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param {string} str String.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.raw.encode = function (str) {\n\tconst buf = new ArrayBuffer(str.length);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tarr[i] = str.charCodeAt(i);\n\t}\n\n\treturn buf;\n};\n\n/**\n * Base32 string conversion.\n * @type {Object}\n */\nUtils.b32 = {};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */\nUtils.b32.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\n/**\n * Converts an ArrayBuffer to a base32 string (RFC 4648).\n * @see https://github.com/LinusU/base32-decode\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Base32 string.\n */\nUtils.b32.decode = function (buf) {\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tvalue = (value << 8) | arr[i];\n\t\tbits += 8;\n\n\t\twhile (bits >= 5) {\n\t\t\tstr += Utils.b32.alphabet[(value >>> bits - 5) & 31];\n\t\t\tbits -= 5;\n\t\t}\n\t}\n\n\tif (bits > 0) {\n\t\tstr += Utils.b32.alphabet[(value << 5 - bits) & 31];\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a base32 string to an ArrayBuffer (RFC 4648).\n * @see https://github.com/LinusU/base32-encode\n * @param {string} str Base32 string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.b32.encode = function (str) {\n\tconst strUpp = str.toUpperCase();\n\tconst buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet index = 0;\n\n\tfor (let i = 0; i < strUpp.length; i++) {\n\t\tlet idx = Utils.b32.alphabet.indexOf(strUpp[i]);\n\n\t\tif (idx === -1) {\n\t\t\tthrow new TypeError('Invalid character found: ' + strUpp[i]);\n\t\t}\n\n\t\tvalue = (value << 5) | idx;\n\t\tbits += 5;\n\n\t\tif (bits >= 8) {\n\t\t\tarr[index++] = (value >>> bits - 8) & 255;\n\t\t\tbits -= 8;\n\t\t}\n\t}\n\n\treturn buf;\n};\n\n/**\n * Hexadecimal string conversion.\n * @type {Object}\n */\nUtils.hex = {};\n\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Hexadecimal string.\n */\nUtils.hex.decode = function (buf) {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst hexByte = arr[i].toString(16);\n\n\t\tstr += hexByte.length === 1\n\t\t\t? '0' + hexByte\n\t\t\t: hexByte;\n\t}\n\n\treturn str.toUpperCase();\n};\n\n/**\n * Converts a hexadecimal string to an ArrayBuffer.\n * @param {string} str Hexadecimal string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.hex.encode = function (str) {\n\tconst buf = new ArrayBuffer(str.length / 2);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tarr[i] = parseInt(str.substr(i * 2, 2), 16);\n\t}\n\n\treturn buf;\n};\n\n/**\n * An object containing some utilities (for internal use only).\n * @private\n * @type {Object}\n */\nconst InternalUtils = {};\n\n/**\n * Detect if running in \"Node.js\".\n * @type {boolean}\n */\n// eslint-disable-next-line dot-notation\nInternalUtils.isNode = Object.prototype.toString.call(global['process']) === '[object process]';\n\n/**\n * Dynamically import \"Node.js\" modules.\n * @param {string} name Name.\n * @returns {Object} Module.\n */\nInternalUtils.require = function (name) {\n\t// eslint-disable-next-line no-eval\n\treturn InternalUtils.isNode ? eval('require')(name) : null;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n  /**\n   * Symmetric ciphers.\n   * @namespace\n   */\n  cipher: {},\n\n  /**\n   * Hash functions.  Right now only SHA256 is implemented.\n   * @namespace\n   */\n  hash: {},\n\n  /**\n   * Key exchange functions.  Right now only SRP is implemented.\n   * @namespace\n   */\n  keyexchange: {},\n  \n  /**\n   * Cipher modes of operation.\n   * @namespace\n   */\n  mode: {},\n\n  /**\n   * Miscellaneous.  HMAC and PBKDF2.\n   * @namespace\n   */\n  misc: {},\n  \n  /**\n   * Bit array encoders and decoders.\n   * @namespace\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /**\n   * Exceptions.\n   * @namespace\n   */\n  exception: {\n    /**\n     * Ciphertext is corrupt.\n     * @constructor\n     */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Invalid parameter.\n     * @constructor\n     */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Bug or missing feature in SJCL.\n     * @constructor\n     */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /**\n     * Something isn't ready.\n     * @constructor\n     */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} blength The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n\n//patch arraybuffers if they don't exist\nif (typeof(ArrayBuffer) === 'undefined') {\n  (function(globals){\n      \"use strict\";\n      globals.ArrayBuffer = function(){};\n      globals.DataView = function(){};\n  }(undefined));\n}\n\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n  /** Convert from a bitArray to an ArrayBuffer. \n   * Will default to 8byte padding if padding is undefined*/\n  fromBits: function (arr, padding, padding_count) {\n    var out, i, ol, tmp, smallest;\n    padding = padding==undefined  ? true : padding;\n    padding_count = padding_count || 8;\n\n    if (arr.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    ol = sjcl.bitArray.bitLength(arr)/8;\n\n    //check to make sure the bitLength is divisible by 8, if it isn't \n    //we can't do anything since arraybuffers work with bytes, not bits\n    if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {\n      throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n    }\n\n    if (padding && ol%padding_count !== 0){\n      ol += padding_count - (ol%padding_count);\n    }\n\n\n    //padded temp for easy copying\n    tmp = new DataView(new ArrayBuffer(arr.length*4));\n    for (i=0; i<arr.length; i++) {\n      tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits\n    }\n\n    //now copy the final message if we are not going to 0 pad\n    out = new DataView(new ArrayBuffer(ol));\n\n    //save a step when the tmp and out bytelength are ===\n    if (out.byteLength === tmp.byteLength){\n      return tmp.buffer;\n    }\n\n    smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n    for(i=0; i<smallest; i++){\n      out.setUint8(i,tmp.getUint8(i));\n    }\n\n\n    return out.buffer;\n  },\n\n  toBits: function (buffer) {\n    var i, out=[], len, inView, tmp;\n\n    if (buffer.byteLength === 0) {\n      return [];\n    }\n\n    inView = new DataView(buffer);\n    len = inView.byteLength - inView.byteLength%4;\n\n    for (var i = 0; i < len; i+=4) {\n      out.push(inView.getUint32(i));\n    }\n\n    if (inView.byteLength%4 != 0) {\n      tmp = new DataView(new ArrayBuffer(4));\n      for (var i = 0, l = inView.byteLength%4; i < l; i++) {\n        //we want the data to the right, because partial slices off the starting bits\n        tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian, \n      }\n      out.push(\n        sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )\n      ); \n    }\n    return out;\n  },\n\n\n\n  /** Prints a hex output of the buffer contents, akin to hexdump **/\n  hexDumpBuffer: function(buffer){\n      var stringBufferView = new DataView(buffer);\n      var string = '';\n      var pad = function (n, width) {\n          n = n + '';\n          return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n      };\n\n      for (var i = 0; i < stringBufferView.byteLength; i+=2) {\n          if (i%16 == 0) string += ('\\n'+(i).toString(16)+'\\t');\n          string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ');\n      }\n\n      if ( typeof console === undefined ){\n        console = console || {log:function(){}}; //fix for IE\n      }\n      console.log(string.toUpperCase());\n  }\n};\n\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n\t\ti+= this.blockSize) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n             i+= this.blockSize) {\n      \t     this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var t, tmp, a, b, c, d, e,\n    h = this._h;\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n        // When words is passed to _block, it has 16 elements. SHA1 _block\n        // function extends words with new elements (at the end there are 80 elements). \n        // The problem is that if we use Uint32Array instead of Array, \n        // the length of Uint32Array cannot be changed. Thus, we replace words with a \n        // normal Array here.\n        w = Array(80); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<16; j++){\n            w[j] = words[j];\n        }\n    } else {\n        w = words;\n    }\n\n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n\tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor, isPrime;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    for (; i<64; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i] = frac(Math.pow(prime, 1/2));\n        }\n        this._key[i] = frac(Math.pow(prime, 1/3));\n        i++;\n      }\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {Uint32Array|bitArray} w one block of words.\n   * @private\n   */\n  _block:function (w) {  \n    var i, tmp, a, b,\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview Javascript SHA-512 implementation.\n *\n * This implementation was written for CryptoJS by Jeff Mott and adapted for\n * SJCL by Stefan Thomas.\n *\n * CryptoJS (c) 2009–2012 by Jeff Mott. All rights reserved.\n * Released with New BSD License\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Jeff Mott\n * @author Stefan Thomas\n */\n\n/**\n * Context for a SHA-512 operation in progress.\n * @constructor\n */\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha512.hash = function (data) {\n  return (new sjcl.hash.sha512()).update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 1024,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n        var c = new Uint32Array(b);\n        var j = 0;\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(c.subarray(32 * j, 32 * (j+1)));\n            j += 1;\n        }\n        b.splice(0, 32 * j);\n    } else {\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(b.splice(0,32));\n        }\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 32 words, less the 4 length words.\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,32));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-512 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n\n  /**\n   * Least significant 24 bits of SHA512 initialization values.\n   *\n   * Javascript only has 53 bits of precision, so we compute the 40 most\n   * significant bits and add the remaining 24 bits as constants.\n   *\n   * @private\n   */\n  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],\n\n  /*\n  _init:\n  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],\n  */\n\n  /**\n   * The SHA-512 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n\n  /**\n   * Least significant 24 bits of SHA512 key values.\n   * @private\n   */\n  _keyr:\n  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,\n   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,\n   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,\n   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,\n   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,\n   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,\n   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,\n   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,\n   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,\n   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n\n  /*\n  _key:\n  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],\n  */\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    // XXX: This code is for precomputing the SHA256 constants, change for\n    //      SHA512 and re-enable.\n    var i = 0, prime = 2, factor , isPrime;\n\n    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }\n    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }\n\n    for (; i<80; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i*2] = frac(Math.pow(prime, 1/2));\n          this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];\n        }\n        this._key[i*2] = frac(Math.pow(prime, 1/3));\n        this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-512.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, wrh, wrl,\n        h = this._h,\n        k = this._key,\n        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],\n        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],\n        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],\n        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n\t// When words is passed to _block, it has 32 elements. SHA512 _block\n\t// function extends words with new elements (at the end there are 160 elements). \n\t// The problem is that if we use Uint32Array instead of Array, \n\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t// normal Array here.\n        w = Array(160); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<32; j++){\n    \t    w[j] = words[j]; \n        }\n    } else {\n\tw = words;\n    } \n\n    // Working variables\n    var ah = h0h, al = h0l, bh = h1h, bl = h1l,\n        ch = h2h, cl = h2l, dh = h3h, dl = h3l,\n        eh = h4h, el = h4l, fh = h5h, fl = h5l,\n        gh = h6h, gl = h6l, hh = h7h, hl = h7l;\n\n    for (i=0; i<80; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        // Gamma0\n        var gamma0xh = w[(i-15) * 2];\n        var gamma0xl = w[(i-15) * 2 + 1];\n        var gamma0h =\n          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^\n          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^\n           (gamma0xh >>> 7);\n        var gamma0l =\n          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^\n          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^\n          ((gamma0xh << 25) | (gamma0xl >>> 7));\n\n        // Gamma1\n        var gamma1xh = w[(i-2) * 2];\n        var gamma1xl = w[(i-2) * 2 + 1];\n        var gamma1h =\n          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^\n          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^\n           (gamma1xh >>> 6);\n        var gamma1l =\n          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^\n          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^\n          ((gamma1xh << 26) | (gamma1xl >>> 6));\n\n        // Shortcuts\n        var wr7h = w[(i-7) * 2];\n        var wr7l = w[(i-7) * 2 + 1];\n\n        var wr16h = w[(i-16) * 2];\n        var wr16l = w[(i-16) * 2 + 1];\n\n        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);\n      }\n\n      w[i*2]     = wrh |= 0;\n      w[i*2 + 1] = wrl |= 0;\n\n      // Ch\n      var chh = (eh & fh) ^ (~eh & gh);\n      var chl = (el & fl) ^ (~el & gl);\n\n      // Maj\n      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      // Sigma0\n      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\n      // Sigma1\n      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));\n      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));\n\n      // K(round)\n      var krh = k[i*2];\n      var krl = k[i*2+1];\n\n      // t1 = h + sigma1 + ch + K(round) + W(round)\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += krl;\n      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);\n      t1l = t1l + wrl|0;   // FF32..FF34 perf issue https://bugzilla.mozilla.org/show_bug.cgi?id=1054972\n      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash\n    h0l = h[1] = (h0l + al) | 0;\n    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;\n    h1l = h[3] = (h1l + bl) | 0;\n    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;\n    h2l = h[5] = (h2l + cl) | 0;\n    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;\n    h3l = h[7] = (h3l + dl) | 0;\n    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n    h4l = h[9] = (h4l + el) | 0;\n    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;\n    h5l = h[11] = (h5l + fl) | 0;\n    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;\n    h6l = h[13] = (h6l + gl) | 0;\n    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;\n    h7l = h[15] = (h7l + hl) | 0;\n    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;\n  }\n};\n\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};\n; /* harmony default export */ __webpack_exports__[\"a\"] = (sjcl);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Crypto; });\n/* harmony import */ var sjcl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n\n\n\n/**\n * Node.js Crypto module.\n * @private\n * @type {Object}\n */\nconst NodeCrypto = _utils_js__WEBPACK_IMPORTED_MODULE_1__[/* InternalUtils */ \"a\"].require('crypto');\n\n/**\n * An object containing some cryptography functions\n * with dirty workarounds for Node.js and browsers.\n * @private\n * @type {Object}\n */\nconst Crypto = {};\n\nif (NodeCrypto) {\n\tlet bufferFrom;\n\n\tif (typeof Buffer.from === 'function') {\n\t\tbufferFrom = Buffer.from;\n\t} else {\n\t\t// Node.js < 5.10.0\n\t\tbufferFrom = function (arrbuf) {\n\t\t\t// eslint-disable-next-line no-buffer-constructor, unicorn/no-new-buffer\n\t\t\tconst nodeBuf = new Buffer(arrbuf.byteLength);\n\t\t\tconst arr = new Uint8Array(arrbuf);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tnodeBuf[i] = arr[i];\n\t\t\t}\n\n\t\t\treturn nodeBuf;\n\t\t};\n\t}\n\n\tlet bufferTo;\n\n\tif (Buffer.prototype instanceof Uint8Array) {\n\t\tbufferTo = function (nodeBuf) {\n\t\t\treturn nodeBuf;\n\t\t};\n\t} else {\n\t\t// Node.js < 4.0.0\n\t\tbufferTo = function (nodeBuf) {\n\t\t\tconst arr = new Uint8Array(nodeBuf.length);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = nodeBuf[i];\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t};\n\t}\n\n\tCrypto.randomBytes = function (size) {\n\t\treturn bufferTo(NodeCrypto.randomBytes(size));\n\t};\n\n\t// In Node.js, the command:\n\t//   $ openssl list-message-digest-algorithms\n\t// displays the available digest algorithms.\n\tCrypto.hmacDigest = function (algorithm, key, message) {\n\t\treturn bufferTo(NodeCrypto.createHmac(algorithm, bufferFrom(key))\n\t\t\t.update(bufferFrom(message))\n\t\t\t.digest());\n\t};\n} else {\n\tlet getRandomValues;\n\n\tif (typeof global.crypto !== 'undefined' && typeof global.crypto.getRandomValues === 'function') {\n\t\tgetRandomValues = function (arr) {\n\t\t\tglobal.crypto.getRandomValues(arr);\n\t\t};\n\t} else if (typeof global.msCrypto !== 'undefined' && typeof global.msCrypto.getRandomValues === 'function') {\n\t\tgetRandomValues = function (arr) {\n\t\t\tglobal.msCrypto.getRandomValues(arr);\n\t\t};\n\t} else {\n\t\tconsole.warn('Cryptography API not available, falling back to \\'Math.random\\'...');\n\t\tgetRandomValues = function (arr) {\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = Math.floor(Math.random() * 256);\n\t\t\t}\n\t\t};\n\t}\n\n\tCrypto.randomBytes = function (size) {\n\t\tconst arr = new Uint8Array(size);\n\t\tgetRandomValues(arr);\n\t\treturn arr;\n\t};\n\n\tCrypto.hmacDigest = function (algorithm, key, message) {\n\t\tconst hash = sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].hash[algorithm.toLowerCase()];\n\t\tif (typeof hash === 'undefined') {\n\t\t\tthrow new TypeError('Unknown hash function');\n\t\t}\n\n\t\t// eslint-disable-next-line new-cap\n\t\tconst hmac = new sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].misc.hmac(sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.toBits(key), hash);\n\t\thmac.update(sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.toBits(message));\n\n\t\treturn sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.fromBits(hmac.digest(), false);\n\t};\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/utils.js\nvar utils = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./src/crypto.js\nvar src_crypto = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./src/secret.js\n\n\n\n/**\n * Secret key object.\n */\nclass secret_Secret {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {ArrayBuffer} [config.buffer=Crypto.randomBytes] Secret key.\n\t * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n\t */\n\tconstructor({buffer, size = 20} = {}) {\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {ArrayBuffer}\n\t\t */\n\t\tthis.buffer = typeof buffer === 'undefined'\n\t\t\t? src_crypto[\"a\" /* Crypto */].randomBytes(size).buffer\n\t\t\t: buffer;\n\t}\n\n\t/**\n\t * Converts a raw string to a Secret object.\n\t * @method fromRaw\n\t * @param {string} str Raw string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromRaw(str) {\n\t\treturn new this({buffer: utils[\"b\" /* Utils */].raw.encode(str)});\n\t}\n\n\t/**\n\t * Converts a base32 string to a Secret object.\n\t * @method fromB32\n\t * @param {string} str Base32 string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromB32(str) {\n\t\treturn new this({buffer: utils[\"b\" /* Utils */].b32.encode(str)});\n\t}\n\n\t/**\n\t * Converts a hexadecimal string to a Secret object.\n\t * @method fromHex\n\t * @param {string} str Hexadecimal string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromHex(str) {\n\t\treturn new this({buffer: utils[\"b\" /* Utils */].hex.encode(str)});\n\t}\n\n\t/**\n\t * String representation of secret key.\n\t * @type {string}\n\t */\n\tget raw() {\n\t\tObject.defineProperty(this, 'raw', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].raw.decode(this.buffer)\n\t\t});\n\n\t\treturn this.raw;\n\t}\n\n\t/**\n\t * Base32 representation of secret key.\n\t * @type {string}\n\t */\n\tget b32() {\n\t\tObject.defineProperty(this, 'b32', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].b32.decode(this.buffer)\n\t\t});\n\n\t\treturn this.b32;\n\t}\n\n\t/**\n\t * Hexadecimal representation of secret key.\n\t * @type {string}\n\t */\n\tget hex() {\n\t\tObject.defineProperty(this, 'hex', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].hex.decode(this.buffer)\n\t\t});\n\n\t\treturn this.hex;\n\t}\n}\n\n// CONCATENATED MODULE: ./src/uri.js\n\n\n\n\n/**\n * Valid key URI parameters.\n * @private\n * @type {Array}\n */\nconst OTPURI_PARAMS = ['issuer', 'label', 'secret', 'algorithm', 'digits', 'counter', 'period'];\n\n/**\n * Key URI regex.\n *   otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n * @private\n * @type {RegExp}\n */\nconst OTPURI_REGEX = new RegExp(`^otpauth:\\\\/\\\\/([ht]otp)\\\\/(.+)\\\\?((?:&?(?:${OTPURI_PARAMS.join('|')})=[^&]+)+)$`, 'i');\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @private\n * @type {string}\n */\nconst SECRET_REGEX = /^[2-7A-Z]+$/i;\n\n/**\n * Regex for supported algorithms.\n * @private\n * @type {RegExp}\n */\nconst ALGORITHM_REGEX = /^SHA(?:1|256|512)$/i;\n\n/**\n * Integer regex.\n * @private\n * @type {RegExp}\n */\nconst INTEGER_REGEX = /^[+-]?\\d+$/;\n\n/**\n * Positive integer regex.\n * @private\n * @type {RegExp}\n */\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n\n/**\n * HOTP/TOTP object/string conversion.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\nclass uri_URI {\n\t/**\n\t * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n\t * @method parse\n\t * @param {string} uri Google Authenticator Key URI.\n\t * @returns {Object} HOTP/TOTP object.\n\t */\n\tstatic parse(uri) {\n\t\tlet uriGroups;\n\n\t\ttry {\n\t\t\turiGroups = decodeURIComponent(uri).match(OTPURI_REGEX);\n\t\t} catch (err) {}\n\n\t\tif (!Array.isArray(uriGroups)) {\n\t\t\tthrow new URIError('Invalid URI format');\n\t\t}\n\n\t\t// Extract URI groups\n\t\tconst uriType = uriGroups[1].toLowerCase();\n\t\tconst uriLabel = uriGroups[2].split(/:(.+)/, 2);\n\t\tconst uriParams = uriGroups[3].split('&').reduce(function (acc, cur) {\n\t\t\tconst pairArr = cur.split(/=(.+)/, 2);\n\t\t\tconst pairKey = pairArr[0].toLowerCase();\n\t\t\tconst pairVal = pairArr[1];\n\t\t\tconst pairAcc = acc;\n\n\t\t\tpairAcc[pairKey] = pairVal;\n\t\t\treturn pairAcc;\n\t\t}, {});\n\n\t\t// 'OTP' will be instantiated with 'config' argument\n\t\tlet OTP;\n\t\tlet config = {};\n\n\t\tif (uriType === 'hotp') {\n\t\t\tOTP = otp_HOTP;\n\n\t\t\t// Counter: required\n\t\t\tif (typeof uriParams.counter !== 'undefined' && INTEGER_REGEX.test(uriParams.counter)) {\n\t\t\t\tconfig.counter = parseInt(uriParams.counter, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Missing or invalid \\'counter\\' parameter');\n\t\t\t}\n\t\t} else if (uriType === 'totp') {\n\t\t\tOTP = otp_TOTP;\n\n\t\t\t// Period: optional\n\t\t\tif (typeof uriParams.period !== 'undefined') {\n\t\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n\t\t\t\t\tconfig.period = parseInt(uriParams.period, 10);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError('Invalid \\'period\\' parameter');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Unknown OTP type');\n\t\t}\n\n\t\t// Label: required\n\t\t// Issuer: optional\n\t\tif (uriLabel.length === 2) {\n\t\t\tconfig.label = uriLabel[1];\n\t\t\tif (typeof uriParams.issuer === 'undefined') {\n\t\t\t\tconfig.issuer = uriLabel[0];\n\t\t\t} else if (uriParams.issuer === uriLabel[0]) {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'issuer\\' parameter');\n\t\t\t}\n\t\t} else {\n\t\t\tconfig.label = uriLabel[0];\n\t\t\tif (typeof uriParams.issuer !== 'undefined') {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t}\n\t\t}\n\n\t\t// Secret: required\n\t\tif (typeof uriParams.secret !== 'undefined' && SECRET_REGEX.test(uriParams.secret)) {\n\t\t\tconfig.secret = new secret_Secret({buffer: utils[\"b\" /* Utils */].b32.encode(uriParams.secret)});\n\t\t} else {\n\t\t\tthrow new TypeError('Missing or invalid \\'secret\\' parameter');\n\t\t}\n\n\t\t// Algorithm: optional\n\t\tif (typeof uriParams.algorithm !== 'undefined') {\n\t\t\tif (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n\t\t\t\tconfig.algorithm = uriParams.algorithm;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'algorithm\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\t// Digits: optional\n\t\tif (typeof uriParams.digits !== 'undefined') {\n\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n\t\t\t\tconfig.digits = parseInt(uriParams.digits, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'digits\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\treturn new OTP(config);\n\t}\n\n\t/**\n\t * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n\t * @method stringify\n\t * @param {Object} otp HOTP/TOTP object.\n\t * @param {Object} [config] Configuration options.\n\t * @param {boolean} [config.legacyIssuer=true] Set issuer label prefix.\n\t * @returns {string} Google Authenticator Key URI.\n\t */\n\tstatic stringify(otp, {legacyIssuer = true} = {}) {\n\t\tconst isHOTP = otp instanceof otp_HOTP;\n\t\tconst isTOTP = otp instanceof otp_TOTP;\n\n\t\tif (!isHOTP && !isTOTP) {\n\t\t\tthrow new TypeError('Invalid \\'HOTP/TOTP\\' object');\n\t\t}\n\n\t\t// Key URI format:\n\t\t// otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n\t\tlet uri = 'otpauth://';\n\n\t\t// Type\n\t\turi += (isTOTP ? 'totp' : 'hotp') + '/';\n\n\t\t// Label and optional issuer\n\t\tif (otp.issuer.length > 0) {\n\t\t\t// Issuer label prefix\n\t\t\tif (legacyIssuer) {\n\t\t\t\turi += `${otp.issuer}:`;\n\t\t\t}\n\n\t\t\turi += `${otp.label}?issuer=${otp.issuer}&`;\n\t\t} else {\n\t\t\t// No issuer\n\t\t\turi += `${otp.label}?`;\n\t\t}\n\n\t\t// Generic parameters\n\t\turi += `secret=${otp.secret.b32}` +\n\t\t\t`&algorithm=${otp.algorithm}` +\n\t\t\t`&digits=${otp.digits}`;\n\n\t\t// Extra parameters\n\t\tif (isTOTP) {\n\t\t\t// TOTP parameters\n\t\t\turi += `&period=${otp.period}`;\n\t\t} else {\n\t\t\t// HOTP parameters\n\t\t\turi += `&counter=${otp.counter}`;\n\t\t}\n\n\t\treturn encodeURI(uri);\n\t}\n}\n\n// CONCATENATED MODULE: ./src/otp.js\n\n\n\n\n\n/**\n * Default configuration.\n * @private\n * @type {Object}\n */\nconst DC = {\n\tissuer: '',\n\tlabel: 'OTPAuth',\n\talgorithm: 'SHA1',\n\tdigits: 6,\n\tcounter: 0,\n\tperiod: 30,\n\twindow: 50,\n\tpad: true\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm (RFC 4226).\n * @see https://tools.ietf.org/html/rfc4226\n */\nclass otp_HOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Initial counter value.\n\t */\n\tconstructor({issuer = DC.issuer, label = DC.label, secret = new secret_Secret(), algorithm = DC.algorithm, digits = DC.digits, counter = DC.counter} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {string}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Initial counter value.\n\t\t * @type {number}\n\t\t */\n\t\tthis.counter = counter;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({secret, algorithm = DC.algorithm, digits = DC.digits, counter = DC.counter, pad = DC.pad}) {\n\t\tconst digest = new Uint8Array(src_crypto[\"a\" /* Crypto */].hmacDigest(algorithm, secret.buffer, utils[\"b\" /* Utils */].uint.encode(counter)));\n\t\tconst offset = digest[digest.byteLength - 1] & 15;\n\t\tconst otp = (\n\t\t\t((digest[offset] & 127) << 24) |\n\t\t\t((digest[offset + 1] & 255) << 16) |\n\t\t\t((digest[offset + 2] & 255) << 8) |\n\t\t\t(digest[offset + 3] & 255)\n\t\t) % Math.pow(10, digits);\n\n\t\treturn pad\n\t\t\t? new Array(1 + digits - String(otp).length).join('0') + otp\n\t\t\t: otp;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.counter=this.counter++] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({counter = this.counter++, pad} = {}) {\n\t\treturn otp_HOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tcounter: counter,\n\t\t\tpad: pad\n\t\t});\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({token, secret, algorithm, counter = DC.counter, window = DC.window}) {\n\t\tconst searchToken = parseInt(token, 10);\n\n\t\tfor (let i = counter - window; i <= counter + window; ++i) {\n\t\t\tconst generatedToken = otp_HOTP.generate({\n\t\t\t\tsecret: secret,\n\t\t\t\talgorithm: algorithm,\n\t\t\t\tcounter: i,\n\t\t\t\tdigits: token.length,\n\t\t\t\tpad: false\n\t\t\t});\n\n\t\t\tif (searchToken === generatedToken) {\n\t\t\t\treturn i - counter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.counter=this.counter] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({token, counter = this.counter, window}) {\n\t\treturn otp_HOTP.validate({\n\t\t\ttoken: token,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tcounter: counter,\n\t\t\twindow: window\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn uri_URI.stringify(this);\n\t}\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm (RFC 6238).\n * @see https://tools.ietf.org/html/rfc6238\n */\nclass otp_TOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t */\n\tconstructor({issuer = DC.issuer, label = DC.label, secret = new secret_Secret(), algorithm = DC.algorithm, digits = DC.digits, period = DC.period} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {string}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Token time-step duration.\n\t\t * @type {number}\n\t\t */\n\t\tthis.period = period;\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({secret, algorithm, digits, period = DC.period, timestamp = Date.now(), pad}) {\n\t\treturn otp_HOTP.generate({\n\t\t\tsecret: secret,\n\t\t\talgorithm: algorithm,\n\t\t\tdigits: digits,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\tpad: pad\n\t\t});\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({timestamp = Date.now(), pad} = {}) {\n\t\treturn otp_TOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp: timestamp,\n\t\t\tpad: pad\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({token, secret, algorithm, period = DC.period, timestamp = Date.now(), window}) {\n\t\treturn otp_HOTP.validate({\n\t\t\ttoken: token,\n\t\t\tsecret: secret,\n\t\t\talgorithm: algorithm,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\twindow: window\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({token, timestamp, window}) {\n\t\treturn otp_TOTP.validate({\n\t\t\ttoken: token,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp: timestamp,\n\t\t\twindow: window\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn uri_URI.stringify(this);\n\t}\n}\n\n// CONCATENATED MODULE: ./src/main.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"HOTP\", function() { return otp_HOTP; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"TOTP\", function() { return otp_TOTP; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"URI\", function() { return uri_URI; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Secret\", function() { return secret_Secret; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Utils\", function() { return utils[\"b\" /* Utils */]; });\n/**\n * One Time Password (HOTP/TOTP) library for Node.js and browser.\n * @module OTPAuth\n * @author Héctor Molinero Fernández <hector@molinero.xyz>\n */\n\n\n\n\n\n/**\n * Library version.\n * @type {string}\n */\nconst version = \"3.2.1\";\n\n\n/***/ })\n/******/ ]);\n});","/**\n * An object containing some utilities.\n * @type {Object}\n */\nexport const Utils = {};\n\n/**\n * UInt conversion.\n * @type {Object}\n */\nUtils.uint = {};\n\n/**\n * Converts an ArrayBuffer to an integer.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {number} Integer.\n */\nUtils.uint.decode = function (buf) {\n\tconst arr = new Uint8Array(buf);\n\tlet num = 0;\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum *= 256;\n\t\tnum += arr[i];\n\t}\n\n\treturn num;\n};\n\n/**\n * Converts an integer to an ArrayBuffer.\n * @param {number} num Integer.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.uint.encode = function (num) {\n\tconst buf = new ArrayBuffer(8);\n\tconst arr = new Uint8Array(buf);\n\tlet acc = num;\n\n\tfor (let i = 7; i >= 0; i--) {\n\t\tif (acc === 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tarr[i] = acc & 255;\n\t\tacc -= arr[i];\n\t\tacc /= 256;\n\t}\n\n\treturn buf;\n};\n\n/**\n * Raw string conversion.\n * @type {Object}\n */\nUtils.raw = {};\n\n/**\n * Converts an ArrayBuffer to a string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} String.\n */\nUtils.raw.decode = function (buf) {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tstr += String.fromCharCode(arr[i]);\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param {string} str String.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.raw.encode = function (str) {\n\tconst buf = new ArrayBuffer(str.length);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tarr[i] = str.charCodeAt(i);\n\t}\n\n\treturn buf;\n};\n\n/**\n * Base32 string conversion.\n * @type {Object}\n */\nUtils.b32 = {};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */\nUtils.b32.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\n/**\n * Converts an ArrayBuffer to a base32 string (RFC 4648).\n * @see https://github.com/LinusU/base32-decode\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Base32 string.\n */\nUtils.b32.decode = function (buf) {\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tvalue = (value << 8) | arr[i];\n\t\tbits += 8;\n\n\t\twhile (bits >= 5) {\n\t\t\tstr += Utils.b32.alphabet[(value >>> bits - 5) & 31];\n\t\t\tbits -= 5;\n\t\t}\n\t}\n\n\tif (bits > 0) {\n\t\tstr += Utils.b32.alphabet[(value << 5 - bits) & 31];\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a base32 string to an ArrayBuffer (RFC 4648).\n * @see https://github.com/LinusU/base32-encode\n * @param {string} str Base32 string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.b32.encode = function (str) {\n\tconst strUpp = str.toUpperCase();\n\tconst buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet index = 0;\n\n\tfor (let i = 0; i < strUpp.length; i++) {\n\t\tlet idx = Utils.b32.alphabet.indexOf(strUpp[i]);\n\n\t\tif (idx === -1) {\n\t\t\tthrow new TypeError('Invalid character found: ' + strUpp[i]);\n\t\t}\n\n\t\tvalue = (value << 5) | idx;\n\t\tbits += 5;\n\n\t\tif (bits >= 8) {\n\t\t\tarr[index++] = (value >>> bits - 8) & 255;\n\t\t\tbits -= 8;\n\t\t}\n\t}\n\n\treturn buf;\n};\n\n/**\n * Hexadecimal string conversion.\n * @type {Object}\n */\nUtils.hex = {};\n\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Hexadecimal string.\n */\nUtils.hex.decode = function (buf) {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst hexByte = arr[i].toString(16);\n\n\t\tstr += hexByte.length === 1\n\t\t\t? '0' + hexByte\n\t\t\t: hexByte;\n\t}\n\n\treturn str.toUpperCase();\n};\n\n/**\n * Converts a hexadecimal string to an ArrayBuffer.\n * @param {string} str Hexadecimal string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.hex.encode = function (str) {\n\tconst buf = new ArrayBuffer(str.length / 2);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tarr[i] = parseInt(str.substr(i * 2, 2), 16);\n\t}\n\n\treturn buf;\n};\n\n/**\n * An object containing some utilities (for internal use only).\n * @private\n * @type {Object}\n */\nexport const InternalUtils = {};\n\n/**\n * Detect if running in \"Node.js\".\n * @type {boolean}\n */\n// eslint-disable-next-line dot-notation\nInternalUtils.isNode = Object.prototype.toString.call(global['process']) === '[object process]';\n\n/**\n * Dynamically import \"Node.js\" modules.\n * @param {string} name Name.\n * @returns {Object} Module.\n */\nInternalUtils.require = function (name) {\n\t// eslint-disable-next-line no-eval\n\treturn InternalUtils.isNode ? eval('require')(name) : null;\n};\n","import sjcl from 'sjcl';\nimport {InternalUtils} from './utils.js';\n\n/**\n * Node.js Crypto module.\n * @private\n * @type {Object}\n */\nconst NodeCrypto = InternalUtils.require('crypto');\n\n/**\n * An object containing some cryptography functions\n * with dirty workarounds for Node.js and browsers.\n * @private\n * @type {Object}\n */\nexport const Crypto = {};\n\nif (NodeCrypto) {\n\tlet bufferFrom;\n\n\tif (typeof Buffer.from === 'function') {\n\t\tbufferFrom = Buffer.from;\n\t} else {\n\t\t// Node.js < 5.10.0\n\t\tbufferFrom = function (arrbuf) {\n\t\t\t// eslint-disable-next-line no-buffer-constructor, unicorn/no-new-buffer\n\t\t\tconst nodeBuf = new Buffer(arrbuf.byteLength);\n\t\t\tconst arr = new Uint8Array(arrbuf);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tnodeBuf[i] = arr[i];\n\t\t\t}\n\n\t\t\treturn nodeBuf;\n\t\t};\n\t}\n\n\tlet bufferTo;\n\n\tif (Buffer.prototype instanceof Uint8Array) {\n\t\tbufferTo = function (nodeBuf) {\n\t\t\treturn nodeBuf;\n\t\t};\n\t} else {\n\t\t// Node.js < 4.0.0\n\t\tbufferTo = function (nodeBuf) {\n\t\t\tconst arr = new Uint8Array(nodeBuf.length);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = nodeBuf[i];\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t};\n\t}\n\n\tCrypto.randomBytes = function (size) {\n\t\treturn bufferTo(NodeCrypto.randomBytes(size));\n\t};\n\n\t// In Node.js, the command:\n\t//   $ openssl list-message-digest-algorithms\n\t// displays the available digest algorithms.\n\tCrypto.hmacDigest = function (algorithm, key, message) {\n\t\treturn bufferTo(NodeCrypto.createHmac(algorithm, bufferFrom(key))\n\t\t\t.update(bufferFrom(message))\n\t\t\t.digest());\n\t};\n} else {\n\tlet getRandomValues;\n\n\tif (typeof global.crypto !== 'undefined' && typeof global.crypto.getRandomValues === 'function') {\n\t\tgetRandomValues = function (arr) {\n\t\t\tglobal.crypto.getRandomValues(arr);\n\t\t};\n\t} else if (typeof global.msCrypto !== 'undefined' && typeof global.msCrypto.getRandomValues === 'function') {\n\t\tgetRandomValues = function (arr) {\n\t\t\tglobal.msCrypto.getRandomValues(arr);\n\t\t};\n\t} else {\n\t\tconsole.warn('Cryptography API not available, falling back to \\'Math.random\\'...');\n\t\tgetRandomValues = function (arr) {\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = Math.floor(Math.random() * 256);\n\t\t\t}\n\t\t};\n\t}\n\n\tCrypto.randomBytes = function (size) {\n\t\tconst arr = new Uint8Array(size);\n\t\tgetRandomValues(arr);\n\t\treturn arr;\n\t};\n\n\tCrypto.hmacDigest = function (algorithm, key, message) {\n\t\tconst hash = sjcl.hash[algorithm.toLowerCase()];\n\t\tif (typeof hash === 'undefined') {\n\t\t\tthrow new TypeError('Unknown hash function');\n\t\t}\n\n\t\t// eslint-disable-next-line new-cap\n\t\tconst hmac = new sjcl.misc.hmac(sjcl.codec.arrayBuffer.toBits(key), hash);\n\t\thmac.update(sjcl.codec.arrayBuffer.toBits(message));\n\n\t\treturn sjcl.codec.arrayBuffer.fromBits(hmac.digest(), false);\n\t};\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import {Utils} from './utils.js';\nimport {Crypto} from './crypto.js';\nimport {Secret} from './secret.js';\nimport {URI} from './uri.js';\n\n/**\n * Default configuration.\n * @private\n * @type {Object}\n */\nconst DC = {\n\tissuer: '',\n\tlabel: 'OTPAuth',\n\talgorithm: 'SHA1',\n\tdigits: 6,\n\tcounter: 0,\n\tperiod: 30,\n\twindow: 50,\n\tpad: true\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm (RFC 4226).\n * @see https://tools.ietf.org/html/rfc4226\n */\nexport class HOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Initial counter value.\n\t */\n\tconstructor({issuer = DC.issuer, label = DC.label, secret = new Secret(), algorithm = DC.algorithm, digits = DC.digits, counter = DC.counter} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {string}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Initial counter value.\n\t\t * @type {number}\n\t\t */\n\t\tthis.counter = counter;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({secret, algorithm = DC.algorithm, digits = DC.digits, counter = DC.counter, pad = DC.pad}) {\n\t\tconst digest = new Uint8Array(Crypto.hmacDigest(algorithm, secret.buffer, Utils.uint.encode(counter)));\n\t\tconst offset = digest[digest.byteLength - 1] & 15;\n\t\tconst otp = (\n\t\t\t((digest[offset] & 127) << 24) |\n\t\t\t((digest[offset + 1] & 255) << 16) |\n\t\t\t((digest[offset + 2] & 255) << 8) |\n\t\t\t(digest[offset + 3] & 255)\n\t\t) % Math.pow(10, digits);\n\n\t\treturn pad\n\t\t\t? new Array(1 + digits - String(otp).length).join('0') + otp\n\t\t\t: otp;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.counter=this.counter++] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({counter = this.counter++, pad} = {}) {\n\t\treturn HOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tcounter: counter,\n\t\t\tpad: pad\n\t\t});\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({token, secret, algorithm, counter = DC.counter, window = DC.window}) {\n\t\tconst searchToken = parseInt(token, 10);\n\n\t\tfor (let i = counter - window; i <= counter + window; ++i) {\n\t\t\tconst generatedToken = HOTP.generate({\n\t\t\t\tsecret: secret,\n\t\t\t\talgorithm: algorithm,\n\t\t\t\tcounter: i,\n\t\t\t\tdigits: token.length,\n\t\t\t\tpad: false\n\t\t\t});\n\n\t\t\tif (searchToken === generatedToken) {\n\t\t\t\treturn i - counter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.counter=this.counter] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({token, counter = this.counter, window}) {\n\t\treturn HOTP.validate({\n\t\t\ttoken: token,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tcounter: counter,\n\t\t\twindow: window\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn URI.stringify(this);\n\t}\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm (RFC 6238).\n * @see https://tools.ietf.org/html/rfc6238\n */\nexport class TOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t */\n\tconstructor({issuer = DC.issuer, label = DC.label, secret = new Secret(), algorithm = DC.algorithm, digits = DC.digits, period = DC.period} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {string}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Token time-step duration.\n\t\t * @type {number}\n\t\t */\n\t\tthis.period = period;\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({secret, algorithm, digits, period = DC.period, timestamp = Date.now(), pad}) {\n\t\treturn HOTP.generate({\n\t\t\tsecret: secret,\n\t\t\talgorithm: algorithm,\n\t\t\tdigits: digits,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\tpad: pad\n\t\t});\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({timestamp = Date.now(), pad} = {}) {\n\t\treturn TOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp: timestamp,\n\t\t\tpad: pad\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({token, secret, algorithm, period = DC.period, timestamp = Date.now(), window}) {\n\t\treturn HOTP.validate({\n\t\t\ttoken: token,\n\t\t\tsecret: secret,\n\t\t\talgorithm: algorithm,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\twindow: window\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({token, timestamp, window}) {\n\t\treturn TOTP.validate({\n\t\t\ttoken: token,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp: timestamp,\n\t\t\twindow: window\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn URI.stringify(this);\n\t}\n}\n","import {Utils} from './utils.js';\nimport {Secret} from './secret.js';\nimport {HOTP, TOTP} from './otp.js';\n\n/**\n * Valid key URI parameters.\n * @private\n * @type {Array}\n */\nconst OTPURI_PARAMS = ['issuer', 'label', 'secret', 'algorithm', 'digits', 'counter', 'period'];\n\n/**\n * Key URI regex.\n *   otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n * @private\n * @type {RegExp}\n */\nconst OTPURI_REGEX = new RegExp(`^otpauth:\\\\/\\\\/([ht]otp)\\\\/(.+)\\\\?((?:&?(?:${OTPURI_PARAMS.join('|')})=[^&]+)+)$`, 'i');\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @private\n * @type {string}\n */\nconst SECRET_REGEX = /^[2-7A-Z]+$/i;\n\n/**\n * Regex for supported algorithms.\n * @private\n * @type {RegExp}\n */\nconst ALGORITHM_REGEX = /^SHA(?:1|256|512)$/i;\n\n/**\n * Integer regex.\n * @private\n * @type {RegExp}\n */\nconst INTEGER_REGEX = /^[+-]?\\d+$/;\n\n/**\n * Positive integer regex.\n * @private\n * @type {RegExp}\n */\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n\n/**\n * HOTP/TOTP object/string conversion.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\nexport class URI {\n\t/**\n\t * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n\t * @method parse\n\t * @param {string} uri Google Authenticator Key URI.\n\t * @returns {Object} HOTP/TOTP object.\n\t */\n\tstatic parse(uri) {\n\t\tlet uriGroups;\n\n\t\ttry {\n\t\t\turiGroups = decodeURIComponent(uri).match(OTPURI_REGEX);\n\t\t} catch (err) {}\n\n\t\tif (!Array.isArray(uriGroups)) {\n\t\t\tthrow new URIError('Invalid URI format');\n\t\t}\n\n\t\t// Extract URI groups\n\t\tconst uriType = uriGroups[1].toLowerCase();\n\t\tconst uriLabel = uriGroups[2].split(/:(.+)/, 2);\n\t\tconst uriParams = uriGroups[3].split('&').reduce(function (acc, cur) {\n\t\t\tconst pairArr = cur.split(/=(.+)/, 2);\n\t\t\tconst pairKey = pairArr[0].toLowerCase();\n\t\t\tconst pairVal = pairArr[1];\n\t\t\tconst pairAcc = acc;\n\n\t\t\tpairAcc[pairKey] = pairVal;\n\t\t\treturn pairAcc;\n\t\t}, {});\n\n\t\t// 'OTP' will be instantiated with 'config' argument\n\t\tlet OTP;\n\t\tlet config = {};\n\n\t\tif (uriType === 'hotp') {\n\t\t\tOTP = HOTP;\n\n\t\t\t// Counter: required\n\t\t\tif (typeof uriParams.counter !== 'undefined' && INTEGER_REGEX.test(uriParams.counter)) {\n\t\t\t\tconfig.counter = parseInt(uriParams.counter, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Missing or invalid \\'counter\\' parameter');\n\t\t\t}\n\t\t} else if (uriType === 'totp') {\n\t\t\tOTP = TOTP;\n\n\t\t\t// Period: optional\n\t\t\tif (typeof uriParams.period !== 'undefined') {\n\t\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n\t\t\t\t\tconfig.period = parseInt(uriParams.period, 10);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError('Invalid \\'period\\' parameter');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Unknown OTP type');\n\t\t}\n\n\t\t// Label: required\n\t\t// Issuer: optional\n\t\tif (uriLabel.length === 2) {\n\t\t\tconfig.label = uriLabel[1];\n\t\t\tif (typeof uriParams.issuer === 'undefined') {\n\t\t\t\tconfig.issuer = uriLabel[0];\n\t\t\t} else if (uriParams.issuer === uriLabel[0]) {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'issuer\\' parameter');\n\t\t\t}\n\t\t} else {\n\t\t\tconfig.label = uriLabel[0];\n\t\t\tif (typeof uriParams.issuer !== 'undefined') {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t}\n\t\t}\n\n\t\t// Secret: required\n\t\tif (typeof uriParams.secret !== 'undefined' && SECRET_REGEX.test(uriParams.secret)) {\n\t\t\tconfig.secret = new Secret({buffer: Utils.b32.encode(uriParams.secret)});\n\t\t} else {\n\t\t\tthrow new TypeError('Missing or invalid \\'secret\\' parameter');\n\t\t}\n\n\t\t// Algorithm: optional\n\t\tif (typeof uriParams.algorithm !== 'undefined') {\n\t\t\tif (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n\t\t\t\tconfig.algorithm = uriParams.algorithm;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'algorithm\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\t// Digits: optional\n\t\tif (typeof uriParams.digits !== 'undefined') {\n\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n\t\t\t\tconfig.digits = parseInt(uriParams.digits, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'digits\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\treturn new OTP(config);\n\t}\n\n\t/**\n\t * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n\t * @method stringify\n\t * @param {Object} otp HOTP/TOTP object.\n\t * @param {Object} [config] Configuration options.\n\t * @param {boolean} [config.legacyIssuer=true] Set issuer label prefix.\n\t * @returns {string} Google Authenticator Key URI.\n\t */\n\tstatic stringify(otp, {legacyIssuer = true} = {}) {\n\t\tconst isHOTP = otp instanceof HOTP;\n\t\tconst isTOTP = otp instanceof TOTP;\n\n\t\tif (!isHOTP && !isTOTP) {\n\t\t\tthrow new TypeError('Invalid \\'HOTP/TOTP\\' object');\n\t\t}\n\n\t\t// Key URI format:\n\t\t// otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n\t\tlet uri = 'otpauth://';\n\n\t\t// Type\n\t\turi += (isTOTP ? 'totp' : 'hotp') + '/';\n\n\t\t// Label and optional issuer\n\t\tif (otp.issuer.length > 0) {\n\t\t\t// Issuer label prefix\n\t\t\tif (legacyIssuer) {\n\t\t\t\turi += `${otp.issuer}:`;\n\t\t\t}\n\n\t\t\turi += `${otp.label}?issuer=${otp.issuer}&`;\n\t\t} else {\n\t\t\t// No issuer\n\t\t\turi += `${otp.label}?`;\n\t\t}\n\n\t\t// Generic parameters\n\t\turi += `secret=${otp.secret.b32}` +\n\t\t\t`&algorithm=${otp.algorithm}` +\n\t\t\t`&digits=${otp.digits}`;\n\n\t\t// Extra parameters\n\t\tif (isTOTP) {\n\t\t\t// TOTP parameters\n\t\t\turi += `&period=${otp.period}`;\n\t\t} else {\n\t\t\t// HOTP parameters\n\t\t\turi += `&counter=${otp.counter}`;\n\t\t}\n\n\t\treturn encodeURI(uri);\n\t}\n}\n","import {Utils} from './utils.js';\nimport {Crypto} from './crypto.js';\n\n/**\n * Secret key object.\n */\nexport class Secret {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {ArrayBuffer} [config.buffer=Crypto.randomBytes] Secret key.\n\t * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n\t */\n\tconstructor({buffer, size = 20} = {}) {\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {ArrayBuffer}\n\t\t */\n\t\tthis.buffer = typeof buffer === 'undefined'\n\t\t\t? Crypto.randomBytes(size).buffer\n\t\t\t: buffer;\n\t}\n\n\t/**\n\t * Converts a raw string to a Secret object.\n\t * @method fromRaw\n\t * @param {string} str Raw string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromRaw(str) {\n\t\treturn new this({buffer: Utils.raw.encode(str)});\n\t}\n\n\t/**\n\t * Converts a base32 string to a Secret object.\n\t * @method fromB32\n\t * @param {string} str Base32 string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromB32(str) {\n\t\treturn new this({buffer: Utils.b32.encode(str)});\n\t}\n\n\t/**\n\t * Converts a hexadecimal string to a Secret object.\n\t * @method fromHex\n\t * @param {string} str Hexadecimal string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromHex(str) {\n\t\treturn new this({buffer: Utils.hex.encode(str)});\n\t}\n\n\t/**\n\t * String representation of secret key.\n\t * @type {string}\n\t */\n\tget raw() {\n\t\tObject.defineProperty(this, 'raw', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.raw.decode(this.buffer)\n\t\t});\n\n\t\treturn this.raw;\n\t}\n\n\t/**\n\t * Base32 representation of secret key.\n\t * @type {string}\n\t */\n\tget b32() {\n\t\tObject.defineProperty(this, 'b32', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.b32.decode(this.buffer)\n\t\t});\n\n\t\treturn this.b32;\n\t}\n\n\t/**\n\t * Hexadecimal representation of secret key.\n\t * @type {string}\n\t */\n\tget hex() {\n\t\tObject.defineProperty(this, 'hex', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.hex.decode(this.buffer)\n\t\t});\n\n\t\treturn this.hex;\n\t}\n}\n","/**\n * One Time Password (HOTP/TOTP) library for Node.js and browser.\n * @module OTPAuth\n * @author Héctor Molinero Fernández <hector@molinero.xyz>\n */\nexport {HOTP, TOTP} from './otp.js';\nexport {URI} from './uri.js';\nexport {Secret} from './secret.js';\nexport {Utils} from './utils.js';\n\n/**\n * Library version.\n * @type {string}\n */\nexport const version = process.env.VERSION;\n"],"sourceRoot":""}