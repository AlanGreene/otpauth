'use strict';

import {Utils} from './Utils.js';
import {Crypto} from './Crypto.js';

/**
 * @class Secret
 */
export class Secret {
	/**
	 * Secret key object.
	 * @param {Object} [config] Configuration options.
	 * @param {ArrayBuffer} [config.buffer=random] Secret key, randomly generated by default.
	 * @param {number} [config.size=20] Number of bytes to generate, ignored if 'buffer' is provided.
	 */
	constructor ({buffer, size = 20} = {}) {
		/** @type {ArrayBuffer} */
		this.buffer = typeof buffer === 'undefined'
			? this.buffer = Crypto.randomBytes(size).buffer
			: buffer;
	}

	/**
	 * Converts a raw string to a Secret object.
	 * @method fromRaw
	 * @param {string} str Raw string.
	 * @returns {Secret} Secret object.
	 */
	static fromRaw (str) {
		return new this({'buffer': Utils.raw.encode(str)});
	}

	/**
	 * Converts a base32 string to a Secret object.
	 * @method fromB32
	 * @param {string} str Base32 string.
	 * @returns {Secret} Secret object.
	 */
	static fromB32 (str) {
		return new this({'buffer': Utils.b32.encode(str)});
	}

	/**
	 * Converts a hexadecimal string to a Secret object.
	 * @method fromHex
	 * @param {string} str Hexadecimal string.
	 * @returns {Secret} Secret object.
	 */
	static fromHex (str) {
		return new this({'buffer': Utils.hex.encode(str)});
	}

	/** @type {string} */
	get raw () {
		Object.defineProperty(this, 'raw', {
			'enumerable': true,
			'configurable': true,
			'writable': true,
			'value': Utils.raw.decode(this.buffer)
		});

		return this.raw;
	}

	/** @type {string} */
	get b32 () {
		Object.defineProperty(this, 'b32', {
			'enumerable': true,
			'configurable': true,
			'writable': true,
			'value': Utils.b32.decode(this.buffer)
		});

		return this.b32;
	}

	/** @type {string} */
	get hex () {
		Object.defineProperty(this, 'hex', {
			'enumerable': true,
			'configurable': true,
			'writable': true,
			'value': Utils.hex.decode(this.buffer)
		});

		return this.hex;
	}
}

